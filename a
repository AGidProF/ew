    const express = require("express");
    const { chromium } = require("playwright");
    const fs = require("fs");
    const path = require("path");
    const crypto = require("crypto");
    const os = require("os");

    const app = express();
    const PORT = 7860;

    // Set EJS sebagai template engine
    app.set("view engine", "ejs");
    app.set("views", path.join(__dirname, "views"));

    // Middleware
    app.use(express.urlencoded({ extended: true }));
    app.use(express.json());
    app.use(express.static(path.join(__dirname, "public")));

    // Global variables untuk tracking
    let serverStats = {
    startTime: Date.now(),
    totalRequests: 0,
    cacheHits: 0,
    cacheMisses: 0,
    errors: 0,
    requestHistory: [],
    browserRestarts: 0,
    lastError: null,
    averageResponseTime: 0,
    totalResponseTime: 0,
    croxyProxyRequests: 0,
    croxyProxyErrors: 0
    };

    // Folder cache persisten
    const CACHE_DIR = path.join("/data", "cache");
    if (!fs.existsSync(CACHE_DIR)) fs.mkdirSync(CACHE_DIR, { recursive: true });

    // TTL cache dalam ms (30 menit)
    const CACHE_TTL = 30 * 60 * 1000;

    // In-memory cache untuk kecepatan instant
    const memoryCache = new Map();

    // Browser instance yang persistent
    let browserInstance = null;
    let browserContext = null;

    // Helper functions (sama seperti sebelumnya)
    function getCacheKey(url) {
    return crypto.createHash('md5').update(url).digest('hex');
    }

    function formatBytes(bytes) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
    }

    function formatDuration(ms) {
    const seconds = Math.floor(ms / 1000);
    const minutes = Math.floor(seconds / 60);
    const hours = Math.floor(minutes / 60);
    const days = Math.floor(hours / 24);
    
    if (days > 0) return `${days}d ${hours % 24}h ${minutes % 60}m`;
    if (hours > 0) return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
    if (minutes > 0) return `${minutes}m ${seconds % 60}s`;
    return `${seconds}s`;
    }

    function getSystemInfo() {
    const memUsage = process.memoryUsage();
    return {
        platform: os.platform(),
        arch: os.arch(),
        nodeVersion: process.version,
        cpuCount: os.cpus().length,
        totalMemory: formatBytes(os.totalmem()),
        freeMemory: formatBytes(os.freemem()),
        processMemory: {
        rss: formatBytes(memUsage.rss),
        heapUsed: formatBytes(memUsage.heapUsed),
        heapTotal: formatBytes(memUsage.heapTotal),
        external: formatBytes(memUsage.external)
        },
        uptime: formatDuration(os.uptime() * 1000),
        loadAverage: os.loadavg().map(avg => avg.toFixed(2))
    };
    }

    function getCacheStats() {
    const fileStats = fs.existsSync(CACHE_DIR) ? fs.readdirSync(CACHE_DIR) : [];
    let totalFileSize = 0;
    let oldestCache = null;
    let newestCache = null;
    
    fileStats.forEach(file => {
        try {
        const filePath = path.join(CACHE_DIR, file);
        const stats = fs.statSync(filePath);
        totalFileSize += stats.size;
        
        if (!oldestCache || stats.mtime < oldestCache) oldestCache = stats.mtime;
        if (!newestCache || stats.mtime > newestCache) newestCache = stats.mtime;
        } catch (error) {
        // Skip corrupted files
        }
    });

    return {
        memoryEntries: memoryCache.size,
        fileEntries: fileStats.length,
        totalFileSize: formatBytes(totalFileSize),
        cacheTTL: CACHE_TTL / 1000 / 60 + " minutes",
        oldestCache: oldestCache ? new Date(oldestCache).toLocaleString() : "N/A",
        newestCache: newestCache ? new Date(newestCache).toLocaleString() : "N/A"
    };
    }

    // Initialize browser
    async function initBrowser() {
    try {
        if (browserInstance && browserInstance.isConnected()) {
        return; // Browser sudah running
        }
        
        browserInstance = await chromium.launch({ 
        headless: true,
        args: [
            '--no-sandbox',
            '--disable-setuid-sandbox',
            '--disable-dev-shm-usage',
            '--disable-gpu',
            '--no-first-run',
            '--no-default-browser-check',
            '--disable-background-timer-throttling',
            '--disable-backgrounding-occluded-windows',
            '--disable-renderer-backgrounding'
        ]
        });
        
        browserContext = await browserInstance.newContext({
        userAgent: 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36'
        });
        
        serverStats.browserRestarts++;
        console.log("âœ… Browser initialized successfully");
    } catch (error) {
        serverStats.lastError = error.message;
        console.error("âŒ Failed to initialize browser:", error);
        throw error;
    }
    }

    // Load cache dari file ke memory
    function loadFileCache() {
    try {
        const files = fs.readdirSync(CACHE_DIR);
        let loadedCount = 0;
        
        files.forEach(file => {
        try {
            const filePath = path.join(CACHE_DIR, file);
            const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
            
            if (Date.now() - data.timestamp < CACHE_TTL) {
            memoryCache.set(file, data);
            loadedCount++;
            } else {
            fs.unlinkSync(filePath);
            }
        } catch (error) {
            console.error(`Failed to load cache file ${file}:`, error);
        }
        });
        
        console.log(`ğŸ“¦ Loaded ${loadedCount} cache entries to memory`);
    } catch (error) {
        console.error("Failed to load file cache:", error);
    }
    }

    // Save cache
    function saveCache(cacheKey, data) {
    const cacheData = { ...data, timestamp: Date.now() };
    memoryCache.set(cacheKey, cacheData);
    
    setImmediate(() => {
        try {
        fs.writeFileSync(
            path.join(CACHE_DIR, cacheKey), 
            JSON.stringify(cacheData, null, 2)
        );
        } catch (error) {
        console.error("Failed to save cache to file:", error);
        }
    });
    }

    // Get cache
    function getCache(cacheKey) {
    const cached = memoryCache.get(cacheKey);
    if (!cached) return null;
    
    if (Date.now() - cached.timestamp > CACHE_TTL) {
        memoryCache.delete(cacheKey);
        setImmediate(() => {
        try {
            const filePath = path.join(CACHE_DIR, cacheKey);
            if (fs.existsSync(filePath)) fs.unlinkSync(filePath);
        } catch (error) {
            console.error("Failed to delete expired cache file:", error);
        }
        });
        return null;
    }
    
    return cached;
    }

    // NEW: CroxyProxy scraping function
    async function scrapeViaCroxyProxy(targetUrl) {
    console.log(`ğŸ”„ [CROXYPROXY] Starting scrape for: ${targetUrl}`);
    
    const page = await browserContext.newPage();
    
    try {
        let targetResponse = null;
        let finalUrl = null;
        
        // Listen untuk response dengan __cpo parameter
        page.on("response", response => {
        const url = response.url();
        if (url.includes("__cpo=")) {
            console.log(`ğŸ¯ [CROXYPROXY] Found target response: ${url}`);
            targetResponse = response;
            finalUrl = url;
        }
        });
        
        // Buka CroxyProxy
        console.log(`ğŸŒ [CROXYPROXY] Opening CroxyProxy...`);
        await page.goto("https://www.croxyproxy.com/", { 
        waitUntil: "domcontentloaded",
        timeout: 15000 
        });
        
        // Tunggu input tersedia
        await page.waitForSelector('input#url', { timeout: 10000 });
        
        // Input URL target
        console.log(`ğŸ“ [CROXYPROXY] Entering target URL...`);
        await page.fill('input#url', targetUrl);
        
        // Klik tombol Go!
        console.log(`ğŸš€ [CROXYPROXY] Clicking Go button...`);
        await page.click('button#requestSubmit');
        
        // Tunggu response target muncul (max 20 detik)
        console.log(`â³ [CROXYPROXY] Waiting for target response...`);
        const start = Date.now();
        while (!targetResponse && Date.now() - start < 20000) {
        await page.waitForTimeout(500);
        }
        
        if (!targetResponse) {
        throw new Error("Target response tidak ditemukan dalam 20 detik");
        }
        
        // Navigate ke URL target yang ditemukan
        console.log(`ğŸ¯ [CROXYPROXY] Navigating to target page...`);
        await page.goto(finalUrl, { 
        waitUntil: "domcontentloaded",
        timeout: 15000 
        });
        
        // Tunggu sampai halaman benar-benar ter-load (bukan loading page)
        console.log(`â³ [CROXYPROXY] Waiting for page to fully load...`);
        
        // Tunggu beberapa detik untuk memastikan content ter-load
        await page.waitForTimeout(3000);
        
        // Cek apakah masih ada loading indicators
        try {
        await page.waitForFunction(
            () => {
            // Cek apakah ada text "Proxy is launching" atau loading indicators
            const text = document.body.innerText;
            return !text.includes("Proxy is launching") && 
                    !text.includes("Loading...") &&
                    !text.includes("Please wait") &&
                    document.readyState === 'complete';
            },
            { timeout: 10000 }
        );
        } catch (timeoutError) {
        console.log(`âš ï¸ [CROXYPROXY] Loading check timeout, continuing...`);
        }
        
        // Ambil HTML final
        const html = await page.content();
        const currentUrl = page.url();
        
        console.log(`âœ… [CROXYPROXY] Successfully scraped via CroxyProxy`);
        console.log(`ğŸ“„ [CROXYPROXY] Content length: ${formatBytes(html.length)}`);
        console.log(`ğŸ”— [CROXYPROXY] Final URL: ${currentUrl}`);
        
        return { html, url: currentUrl };
        
    } catch (error) {
        console.error(`âŒ [CROXYPROXY] Error:`, error.message);
        serverStats.croxyProxyErrors++;
        throw error;
    } finally {
        await page.close().catch(() => {});
    }
    }

    // DASHBOARD ROUTE - Server-side rendering (sama seperti sebelumnya)
    app.get("/", (req, res) => {
    const systemInfo = getSystemInfo();
    const cacheStats = getCacheStats();
    
    const uptime = Date.now() - serverStats.startTime;
    const avgResponseTime = serverStats.totalRequests > 0 
        ? (serverStats.totalResponseTime / serverStats.totalRequests).toFixed(2)
        : 0;
    
    const hitRate = serverStats.totalRequests > 0 
        ? ((serverStats.cacheHits / serverStats.totalRequests) * 100).toFixed(1)
        : 0;

    const recentRequests = serverStats.requestHistory.slice(-10).reverse();
    
    const cacheEntries = Array.from(memoryCache.entries()).map(([key, data]) => ({
        key: key.substring(0, 8) + '...',
        url: data.url || 'Unknown',
        size: formatBytes(JSON.stringify(data.html).length),
        created: new Date(data.timestamp).toLocaleString(),
        age: formatDuration(Date.now() - data.timestamp)
    })).slice(0, 20);

    res.render("dashboard", {
        title: "CroxyProxy Scraper Dashboard",
        serverStats: {
        ...serverStats,
        uptime: formatDuration(uptime),
        averageResponseTime: avgResponseTime,
        hitRate: hitRate,
        errorRate: serverStats.totalRequests > 0 
            ? ((serverStats.errors / serverStats.totalRequests) * 100).toFixed(1)
            : 0,
        croxyProxySuccessRate: serverStats.croxyProxyRequests > 0
            ? (((serverStats.croxyProxyRequests - serverStats.croxyProxyErrors) / serverStats.croxyProxyRequests) * 100).toFixed(1)
            : 0
        },
        systemInfo,
        cacheStats,
        recentRequests,
        cacheEntries,
        browserStatus: browserInstance?.isConnected() ? 'Connected' : 'Disconnected',
        currentTime: new Date().toLocaleString(),
        query: req.query
    });
    });

    // Test URL form handler (updated untuk CroxyProxy)
    app.post("/test", async (req, res) => {
    const { testUrl } = req.body;
    
    if (!testUrl) {
        return res.redirect("/?error=URL is required");
    }
    
    try {
        const startTime = Date.now();
        const cacheKey = getCacheKey(testUrl);
        const cached = getCache(cacheKey);
        
        let result = {
        url: testUrl,
        cached: !!cached,
        responseTime: 0,
        success: false,
        contentLength: 0,
        error: null,
        method: 'RieL-Proxy'
        };
        
        if (cached) {
        result.success = true;
        result.responseTime = Date.now() - startTime;
        result.contentLength = cached.html.length;
        serverStats.cacheHits++;
        } else {
        if (!browserInstance || !browserInstance.isConnected()) {
            await initBrowser();
        }

        try {
            serverStats.croxyProxyRequests++;
            const scrapeResult = await scrapeViaCroxyProxy(testUrl);
            
            result.success = true;
            result.responseTime = Date.now() - startTime;
            result.contentLength = scrapeResult.html.length;
            
            saveCache(cacheKey, scrapeResult);
            serverStats.cacheMisses++;
            
        } catch (error) {
            result.error = error.message;
            serverStats.errors++;
        }
        }
        
        serverStats.totalRequests++;
        serverStats.totalResponseTime += result.responseTime;
        serverStats.requestHistory.push({
        ...result,
        timestamp: new Date().toLocaleString()
        });
        
        const queryParams = new URLSearchParams({
        testResult: JSON.stringify(result)
        });
        
        res.redirect(`/?${queryParams.toString()}`);
        
    } catch (error) {
        serverStats.errors++;
        serverStats.lastError = error.message;
        res.redirect(`/?error=${encodeURIComponent(error.message)}`);
    }
    });

    // Clear cache handler (sama seperti sebelumnya)
    app.post("/clear-cache", (req, res) => {
    memoryCache.clear();
    
    setImmediate(() => {
        try {
        const files = fs.readdirSync(CACHE_DIR);
        files.forEach(file => fs.unlinkSync(path.join(CACHE_DIR, file)));
        } catch (error) {
        console.error("Failed to clear file cache:", error);
        }
    });
    
    res.redirect("/?success=Cache cleared successfully");
    });

    // Restart browser handler (sama seperti sebelumnya)
    app.post("/restart-browser", async (req, res) => {
    try {
        if (browserContext) await browserContext.close();
        if (browserInstance) await browserInstance.close();
        
        await initBrowser();
        res.redirect("/?success=Browser restarted successfully");
    } catch (error) {
        serverStats.lastError = error.message;
        res.redirect(`/?error=${encodeURIComponent(error.message)}`);
    }
    });

    // MAIN PROXY ENDPOINT - Updated untuk menggunakan CroxyProxy
    app.get("/proxy", async (req, res) => {
    const startTime = Date.now();
    const targetUrl = req.query.url;
    const noCache = req.query.nocache === 'true';
    
    serverStats.totalRequests++;
    
    if (!targetUrl) {
        serverStats.errors++;
        return res.status(400).json({ error: "Missing ?url= parameter" });
    }

    const cacheKey = getCacheKey(targetUrl);
    const cached = noCache ? null : getCache(cacheKey);
    
    if (cached && !noCache) {
        console.log(`âš¡ [CACHE HIT] ${targetUrl}`);
        serverStats.cacheHits++;
        const responseTime = Date.now() - startTime;
        serverStats.totalResponseTime += responseTime;
        
        serverStats.requestHistory.push({
        url: targetUrl,
        cached: true,
        responseTime,
        success: true,
        contentLength: cached.html.length,
        timestamp: new Date().toLocaleString(),
        method: 'Cache'
        });
        
        res.set('X-Cache', 'HIT');
        res.set('X-Method', 'Cache');
        return res.send(cached.html);
    }

    if (noCache) {
        console.log(`ğŸš« [NO CACHE] Bypassing cache: ${targetUrl}`);
    } else {
        console.log(`ğŸ”„ [CACHE MISS] Fetching via CroxyProxy: ${targetUrl}`);
    }
    
    serverStats.cacheMisses++;
    
    if (!browserInstance || !browserInstance.isConnected()) {
        await initBrowser();
    }
    
    try {
        serverStats.croxyProxyRequests++;
        const scrapeResult = await scrapeViaCroxyProxy(targetUrl);
        const responseTime = Date.now() - startTime;

        if (!noCache) {
        saveCache(cacheKey, scrapeResult);
        }
        
        serverStats.totalResponseTime += responseTime;

        serverStats.requestHistory.push({
        url: targetUrl,
        cached: false,
        responseTime,
        success: true,
        contentLength: scrapeResult.html.length,
        timestamp: new Date().toLocaleString(),
        method: 'RieL-Proxy'
        });

        if (noCache) {
        console.log(`ğŸš« [NO CACHE] ${targetUrl} (${responseTime}ms) - CroxyProxy bypass`);
        res.set('X-Cache', 'BYPASS');
        } else {
        console.log(`ğŸ’¾ [CACHED] ${targetUrl} (${responseTime}ms) - CroxyProxy`);
        res.set('X-Cache', 'MISS');
        }

        res.set('X-Method', 'RieL-Proxy');
        res.send(scrapeResult.html);

    } catch (error) {
        const responseTime = Date.now() - startTime;
        serverStats.errors++;
        serverStats.lastError = error.message;
        serverStats.totalResponseTime += responseTime;
        
        serverStats.requestHistory.push({
        url: targetUrl,
        cached: false,
        responseTime,
        success: false,
        error: error.message,
        timestamp: new Date().toLocaleString(),
        method: 'RieL-Proxy'
        });

        console.error(`âŒ [ERROR] ${targetUrl}: ${error.message}`);
        res.status(500).json({ 
        error: "Failed to fetch via CroxyProxy", 
        message: error.message,
        url: targetUrl 
        });
    }
    });

    // API endpoint untuk refresh dashboard data
    app.get("/api/stats", (req, res) => {
    const systemInfo = getSystemInfo();
    const cacheStats = getCacheStats();
    const uptime = Date.now() - serverStats.startTime;
    
    res.json({
        serverStats: {
        ...serverStats,
        uptime: formatDuration(uptime),
        averageResponseTime: serverStats.totalRequests > 0 
            ? (serverStats.totalResponseTime / serverStats.totalRequests).toFixed(2)
            : 0,
        hitRate: serverStats.totalRequests > 0 
            ? ((serverStats.cacheHits / serverStats.totalRequests) * 100).toFixed(1)
            : 0,
        errorRate: serverStats.totalRequests > 0 
            ? ((serverStats.errors / serverStats.totalRequests) * 100).toFixed(1)
            : 0,
        croxyProxySuccessRate: serverStats.croxyProxyRequests > 0
            ? (((serverStats.croxyProxyRequests - serverStats.croxyProxyErrors) / serverStats.croxyProxyRequests) * 100).toFixed(1)
            : 0
        },
        systemInfo,
        cacheStats,
        browserStatus: browserInstance?.isConnected() ? 'Connected' : 'Disconnected',
        currentTime: new Date().toLocaleString(),
        recentRequests: serverStats.requestHistory.slice(-10).reverse()
    });
    });

    // Cleanup expired cache (sama seperti sebelumnya)
    setInterval(() => {
    const now = Date.now();
    let deletedCount = 0;
    
    for (const [key, data] of memoryCache.entries()) {
        if (now - data.timestamp > CACHE_TTL) {
        memoryCache.delete(key);
        deletedCount++;
        }
    }
    
    if (deletedCount > 0) {
        console.log(`ğŸ§¹ Cleaned up ${deletedCount} expired cache entries`);
    }
    }, 5 * 60 * 1000);

    // Graceful shutdown (sama seperti sebelumnya)
    process.on('SIGINT', async () => {
    console.log('\nğŸ›‘ Shutting down gracefully...');
    
    if (browserContext) await browserContext.close();
    if (browserInstance) await browserInstance.close();
    
    process.exit(0);
    });

    // Start server
    async function startServer() {
    await initBrowser();
    loadFileCache();
    
    app.listen(PORT, () => {
        console.log(`ğŸš€ CroxyProxy Scraper Dashboard running on http://localhost:${PORT}`);
        console.log(`ğŸ“Š Loaded ${memoryCache.size} cache entries`);
        console.log(`ğŸ¯ Dashboard: http://localhost:${PORT}`);
        console.log(`ğŸ”§ Proxy API: http://localhost:${PORT}/proxy?url=WEBSITE_URL`);
        console.log(`ğŸš« No Cache: http://localhost:${PORT}/proxy?url=WEBSITE_URL&nocache=true`);
        console.log(`ğŸŒ Method: RieL-Proxy Integration`);
    });
    }

    startServer().catch(console.error);
