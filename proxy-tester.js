// proxy-tester.js - Simple & Guaranteed Working Version
const axios = require("axios");
const { HttpsProxyAgent } = require("https-proxy-agent");
const fs = require("fs").promises;

console.log("üöÄ Starting Simple Proxy Tester for GitHub Actions...");

// Proxy sources
const proxySources = [
  "https://api.proxyscrape.com/v2/?request=get&protocol=http&timeout=10000&format=textplain",
  "https://raw.githubusercontent.com/monosans/proxy-list/main/proxies/http.txt",
  "https://raw.githubusercontent.com/clarketm/proxy-list/master/proxy-list-raw.txt",
  "https://raw.githubusercontent.com/ShiftyTR/Proxy-List/master/http.txt",
  "https://raw.githubusercontent.com/roosterkid/openproxylist/main/HTTPS_RAW.txt",
  "https://raw.githubusercontent.com/TheSpeedX/PROXY-List/master/http.txt",
  "https://raw.githubusercontent.com/sunny9577/proxy-scraper/master/proxies.txt"
];

// Test URLs - simple and fast
const testUrls = [
  "https://httpbin.org/ip",
  "https://otakudesu.best/anime/watanare-sub-indo"
];

class SimpleProxyTester {
  constructor() {
    this.workingProxies = [];
    this.allProxies = new Set();
    this.results = {
      tested: 0,
      working: 0,
      startTime: new Date()
    };
  }

  log(message) {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] ${message}`);
  }

  async fetchProxies() {
    this.log("üì° Fetching proxies from sources...");
    
    for (let i = 0; i < proxySources.length; i++) {
      try {
        this.log(`üì• Fetching source ${i + 1}/${proxySources.length}...`);
        
        const response = await axios.get(proxySources[i], {
          timeout: 20000,
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; ProxyTester/1.0)'
          }
        });
        
        if (response.data) {
          const proxies = response.data
            .toString()
            .split(/[\r\n]+/)
            .map(line => line.trim())
            .filter(line => /^\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}:\d{1,5}$/.test(line));
          
          let newCount = 0;
          proxies.forEach(proxy => {
            if (!this.allProxies.has(proxy)) {
              this.allProxies.add(proxy);
              newCount++;
            }
          });
          
          this.log(`‚úÖ Source ${i + 1}: Found ${proxies.length} proxies (${newCount} new)`);
        }
      } catch (error) {
        this.log(`‚ùå Source ${i + 1} failed: ${error.message.substring(0, 50)}`);
      }
    }
    
    this.log(`üìä Total unique proxies collected: ${this.allProxies.size}`);
  }

  async testProxy(proxy) {
    const startTime = Date.now();
    
    for (const testUrl of testUrls) {
      try {
        const agent = new HttpsProxyAgent(`http://${proxy}`);
        
        const response = await axios.get(testUrl, {
          timeout: 6000,
          httpsAgent: agent,
          headers: {
            'User-Agent': 'Mozilla/5.0 (compatible; ProxyTester/1.0)'
          },
          validateStatus: status => status === 200
        });
        
        if (response.data) {
          const responseTime = Date.now() - startTime;
          return { success: true, responseTime, testUrl };
        }
      } catch (error) {
        // Continue to next test URL
      }
    }
    
    return { success: false, responseTime: Date.now() - startTime };
  }

  async saveWorkingProxy(proxy, testResult) {
    try {
      // IMMEDIATELY save to hasil.txt
      await fs.appendFile('hasil.txt', `${proxy}\n`);
      
      // Also save detailed info
      const logEntry = `[${new Date().toISOString()}] ‚úÖ ${proxy} | ${testResult.responseTime}ms | via ${testResult.testUrl}\n`;
      await fs.appendFile('working_proxies.log', logEntry);
      
      this.log(`üü¢ WORKING: ${proxy} (${testResult.responseTime}ms) - SAVED TO hasil.txt`);
      
    } catch (error) {
      this.log(`‚ùå Error saving ${proxy}: ${error.message}`);
      
      // Fallback saves
      try {
        await fs.appendFile('backup_hasil.txt', `${proxy}\n`);
        this.log(`üíæ Saved to backup: ${proxy}`);
      } catch (backupError) {
        console.log(`EMERGENCY PROXY: ${proxy}`);
      }
    }
  }

  async testAllProxies() {
    const proxiesList = Array.from(this.allProxies);
    
    if (proxiesList.length === 0) {
      this.log("‚ùå No proxies to test!");
      return;
    }
    
    // Initialize hasil.txt with header
    const header = `# Working Proxies - Auto-generated by GitHub Actions
# Generated: ${new Date().toISOString()}
# Repository: GitHub Actions Proxy Tester

`;
    await fs.writeFile('hasil.txt', header);
    await fs.writeFile('working_proxies.log', `# Working Proxies Log - ${new Date().toISOString()}\n`);
    
    this.log(`üß™ Testing ${proxiesList.length} proxies...`);
    
    // Test in smaller batches for better performance
    const batchSize = 20;
    const concurrency = 8;
    
    for (let i = 0; i < proxiesList.length; i += batchSize) {
      const batch = proxiesList.slice(i, i + batchSize);
      const batchNum = Math.floor(i / batchSize) + 1;
      const totalBatches = Math.ceil(proxiesList.length / batchSize);
      
      this.log(`üîÑ Testing batch ${batchNum}/${totalBatches} (${batch.length} proxies)`);
      
      // Process batch with limited concurrency
      for (let j = 0; j < batch.length; j += concurrency) {
        const concurrent = batch.slice(j, j + concurrency);
        
        const promises = concurrent.map(async (proxy) => {
          this.results.tested++;
          const result = await this.testProxy(proxy);
          
          if (result.success) {
            this.results.working++;
            this.workingProxies.push({ proxy, ...result });
            await this.saveWorkingProxy(proxy, result);
          } else {
            this.log(`üî¥ DEAD: ${proxy} (${result.responseTime}ms)`);
          }
        });
        
        await Promise.allSettled(promises);
      }
      
      const progress = ((this.results.tested / proxiesList.length) * 100).toFixed(1);
      this.log(`üìä Batch ${batchNum}/${totalBatches} complete | Working: ${this.results.working} | Progress: ${progress}%`);
      
      // Small delay between batches
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
    
    this.log(`üéØ Testing complete! Found ${this.results.working} working proxies out of ${this.results.tested} tested`);
  }

  async finalizeResults() {
    const duration = Math.round((Date.now() - this.results.startTime) / 1000);
    
    // Create final summary
    const summary = {
      summary: {
        totalTested: this.results.tested,
        totalWorking: this.results.working,
        successRate: ((this.results.working / this.results.tested) * 100).toFixed(2) + '%',
        duration: duration + 's'
      },
      timestamp: new Date().toISOString(),
      topProxies: this.workingProxies
        .sort((a, b) => a.responseTime - b.responseTime)
        .slice(0, 5)
        .map(p => ({ proxy: p.proxy, responseTime: p.responseTime }))
    };
    
    await fs.writeFile('stats.json', JSON.stringify(summary, null, 2));
    
    // Ensure hasil.txt has content or create emergency version
    try {
      const hasilContent = await fs.readFile('hasil.txt', 'utf8');
      const proxyCount = (hasilContent.match(/^\d+\.\d+\.\d+\.\d+:\d+$/gm) || []).length;
      
      if (proxyCount === 0 && this.workingProxies.length > 0) {
        this.log("üö® hasil.txt is empty, recreating...");
        const workingList = this.workingProxies.map(p => p.proxy).join('\n');
        await fs.writeFile('hasil.txt', `# Working Proxies\n# Total: ${this.workingProxies.length}\n\n${workingList}\n`);
      }
      
      this.log(`‚úÖ hasil.txt contains ${proxyCount} working proxies`);
      
    } catch (error) {
      this.log(`‚ö†Ô∏è Error checking hasil.txt: ${error.message}`);
      
      // Emergency recreation
      if (this.workingProxies.length > 0) {
        const emergencyList = this.workingProxies.map(p => p.proxy).join('\n');
        await fs.writeFile('hasil.txt', `# Emergency Recovery\n# Total: ${this.workingProxies.length}\n\n${emergencyList}\n`);
        this.log(`üö® Emergency hasil.txt created with ${this.workingProxies.length} proxies`);
      }
    }
    
    // Final verification
    try {
      const files = await fs.readdir('.');
      const resultFiles = files.filter(f => f.endsWith('.txt') || f.endsWith('.log') || f.endsWith('.json'));
      this.log(`üìÅ Generated files: ${resultFiles.join(', ')}`);
      
      for (const file of resultFiles) {
        const stats = await fs.stat(file);
        this.log(`üìÑ ${file}: ${stats.size} bytes`);
      }
    } catch (error) {
      this.log(`‚ö†Ô∏è File verification error: ${error.message}`);
    }
    
    console.log('\n' + '='.repeat(50));
    console.log('üéØ FINAL SUMMARY');
    console.log('='.repeat(50));
    console.log(`‚úÖ Working Proxies: ${this.results.working}`);
    console.log(`üß™ Total Tested: ${this.results.tested}`);
    console.log(`üìä Success Rate: ${((this.results.working / this.results.tested) * 100).toFixed(2)}%`);
    console.log(`‚è±Ô∏è Duration: ${duration}s`);
    console.log(`üìÑ Results saved to: hasil.txt`);
    console.log('='.repeat(50));
  }

  async run() {
    try {
      await this.fetchProxies();
      await this.testAllProxies();
      await this.finalizeResults();
      
      this.log("üéâ Proxy testing completed successfully!");
      
    } catch (error) {
      this.log(`‚ùå Fatal error: ${error.message}`);
      
      // Emergency save what we have
      if (this.workingProxies.length > 0) {
        const emergencyList = this.workingProxies.map(p => p.proxy).join('\n');
        await fs.writeFile('hasil.txt', `# Error Recovery - ${error.message}\n\n${emergencyList}\n`);
        this.log(`üö® Saved ${this.workingProxies.length} proxies despite error`);
      }
      
      throw error;
    }
  }
}

// Run the tester
if (require.main === module) {
  const tester = new SimpleProxyTester();
  tester.run().catch(error => {
    console.error('Fatal error:', error.message);
    process.exit(1);
  });
}

module.exports = SimpleProxyTester;
